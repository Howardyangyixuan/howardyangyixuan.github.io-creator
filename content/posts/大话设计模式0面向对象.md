---
title: "大话设计模式：0.面向对象基础"
date: 2020-05-14T22:24:58+08:00
draft: false
tags: ["设计模式", "面向对象"]
categories: ["大话设计模式笔记"]
---

# 大话设计模式：0.面向对象基础

去年软工课上张老师苦口婆心：多线程+设计模式，没有总结性的博客和笔记，拖了快一年了。终于找到了合适的方式重新开始了。

<!-- TOC -->

- [大话设计模式：0.面向对象基础](#大话设计模式0面向对象基础)
  - [1. 类 & 对象](#1-类--对象)
  - [2. 重载(overload) & 重写(override)](#2-重载overload--重写override)
  - [3. 字段 & 属性](#3-字段--属性)
  - [4. OO 三大特性：](#4-oo三大特性)
    - [4.1. 封装](#41-封装)
    - [4.2. 继承](#42-继承)
    - [4.3. 多态](#43-多态)
  - [5. 抽象类 & 接口：](#5-抽象类--接口)
    - [5.1. 抽象类：自底向上](#51-抽象类自底向上)
    - [5.2. 接口：自顶向下](#52-接口自顶向下)
    - [5.3. 抽象类 vs 接口](#53-抽象类-vs-接口)

<!-- /TOC -->

## 1. 类 & 对象

一切事物都是对象，每一个实例都是一个对象，而类是对象的抽象，类是一个具有共同属性或特征的事物的集合，一般通过对不同对象的观察，进行总结而得出，类的抽象是一个自底向上的过程。

> 1. 对象：一个自包含的实体，可以用一组特性和行为来标识（自包含：无需其他组件，即可被独立使用）
> 2. 类： 具有相同属性和功能对象的抽象的集合。
> 3. 实例：真实的对象
> 4. 实例化： 创建对象的过程
> 5. 构造方法：类的初始化，也是实例化

## 2. 重载(overload) & 重写(override)

重载：**一个类的每一个实例**都可以有多个同名函数，只需参数类型或个数不同即可。

重写：**父类与子类的实例间**子类重新实现父类的方法

## 3. 字段 & 属性

字段是类内数据/变量，属性不等于字段，属性是一个（get）或一对（get&set）用于获取/改变字段的方法。

## 4. OO 三大特性：

### 4.1. 封装

封装是对象的特性，封装是指对象本身已经具备所有需要的信息并可以自己完成操作。

封装的优点：减少耦合/类内独立修改/清晰的对外接口。其实是从三个角度描述同一件事儿。

### 4.2. 继承

继承是类间的 is-a 关系，且不可逆，派生类 is-a 基类，子类 is-a 父类。

1. 子类具有父类非 private 的属性和方法
2. 子类具有自己的属性和方法
3. 子类可以重写(override)父类方法

注意构造函数，只能被调用，不能被继承。has-a 关系，不应用继承，而应该用组合/聚合。

继承的优点：代码共享/避免重复/便于修改。

继承的缺点：1.高耦合，父类变，子类自动变 2.父类暴露细节(protected 的方法和变量/数据)，破坏了封装，这点理解还不充分。

### 4.3. 多态

多态指**父类与子类的实例间/有相同接口的实例间**可以有同名方法，但实现不同。从子类角度，子类间同名方法，效果也不同。只有对象继承链最末端方法会被调用。

1. 子类以父类身份出现，即对象声明必须为父类
2. 子类调用自己的方法
3. 子类的特有属性和方法不可用

## 5. 抽象类 & 接口：

类是对实例抽象
抽象类是对类的抽象
接口是对方法/行为的抽象

### 5.1. 抽象类：自底向上

抽象类：实例化没有意义的类，只作为父类出现。继承关系树中，抽象类树枝节点，类是叶子结点。

1. 抽象类不能实例化
2. 抽象方法必须被子类重写
3. 类中有抽象方法，类必须被定义为抽象类

### 5.2. 接口：自顶向下

接口：隐式组合方法和属性，封装特定功能。接口与类是多对多的关系。

1. 接口不能实例化
2. 实现接口的类必须实现接口所有方法和属性

### 5.3. 抽象类 vs 接口

1. 抽象类可以有一些成员的实现，接口不能包含成员实现。反过来说，抽象类可被子类部分实现，接口必须被实现类完全实现。
2. 相似的类间对象，用继承抽象类。跨类间的对象，使用接口。
3. 设计角度：抽象类现有对象，后总结出抽象类，自底向上，一般是重构得到的。接口不知子类存在，预先定义方法，自顶向下。
